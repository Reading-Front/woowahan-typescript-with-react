12장 타입스크립트 프로젝트 관리

# 12.1 앰비언트 타입 활용하기

> 엠비언트(ambient)는 사전적으로 ‘주변의’란 의미를 가진다.

## (1) 앰비언트 타입 선언

### 앰비언트 타입 선언

`.d.ts` 확장자를 가진 파일에서 하는 타입 선언을 **앰비언트(ambient) 타입 선언**이라고 부른다.

이 파일에서는 타입만 할 수 있으며 값을 표현할 수는 없다.

엠비언트 타입 선언으로 값을 정의할 수는 없지만 declare라는 키워드를 시용하여 어딘가에 자바스크립트 값이 존재한다는 사실을 선언할 수 있다.

**declare**는 타입스크립트 컴파일러에 어떤 것의 존재 여부를 명시해주는 역할을 한다. 단순히 존재 여부만 알려주기 때문에 컴파일 대상이 아니다.

### 앰비언트 타입 선언 활용 사례 (1) .ts, .js가 아닌 파일을 모듈로 임포트

js가 아닌 타입스크립트에서 png 등 이미지 파일을 모듈로 임포트할 때 종종 에러가 발생한다.

타입스크립트는 기본적으로 .ts와 .js 파일만 이해하며 그 외의 다른 파일 형식은 인식하지 못한다. 따라서 알지 못하는 파일 형식을 모듈로 가져오려 하면 에러가 발생한다.

이런 상황에서 declare 키워드를 사용하여 특정 형식을 모듈로 선언하면 타입스크립트 컴파일러에 미리 정보를 제공하여 에러를 수정할 수 있다.

> declare 키워드는 이미 존재하지만 타입스크립트가 알지 못하는 부분을 컴파일러에 알려주는 역할

```tsx
declare module '*.png' {
  const src: string
  export default src
}
```

### 앰비언트 타입 선언 활용 사례 (2) 자바스크립트로 작성된 라이브러리

자바스크립트로 구현되어 있으므로 타입선언이 존재 하지 않는다. 따라서 임포트한 모듈은 모두 any로 추론된다. 만약 tsconfig.json 파일에서 any를 사용하지 못하게 설정했다면 프로젝트가 빌드되지 않을 것이다. 이때 앰비언트 타입 선언을 사용할 수 있다.

타입을 앰비언트 타입으로 선언하면 타입스크립트는 자동으로 .d.ts 확장자를 가진 파일을 검색하여 타입 검사를 진행하게 되므로 문제없이 컴파일된다.

> tsc는 별도 설정 없이도 node_modules/@types 에 있는 타입 선언을 타입 검사에 활용한다.
> VSCode는 index.d.ts와 global.d.ts 파일을 활용하여 코드 작성 시 유용한 타입 힌트를 제공한다.

### 앰비언트 타입 선언 활용 사례 (3) 타입스크립트로 작성된 라이브러리

타입스크립트로 작성된 라이브러리일지라도 자바스크립트 파일과 .d.ts 파일로 배포되는 것이 일반적이다.

타입스크립트 파일을 직접 배포하여 라이브러리 사용자가 타입스크립트를 컴파일 할 때 라이브러리 코드도 함께 컴파일하게 할 수도 있다. 그러나 자바스크립트 파일과 .d.ts 파일로 배포하면 라이브러리 코드를 따로 컴파일하지 않아도 되기 때문에 컴파일 시간이 크게 줄어든다.

또한 .d.ts 파일이 있기 때문에 시용자는 .d.ts 파일에 정의된 타입 정보를 활용하여 라이브러리를 시용할 수 있다. 또한 tsconfig.json 파일의 declaration을 true로 설정하면 타입스크립트 컴파일러는 자동으로 .d.ts 파일을 생성한다.

### 앰비언트 타입 선언 활용 사례 (4) 자바스크립트 어딘가에 전역 변수가 정의되어 있음을 타입스크립트에 알릴 때

타입스크립트로 직접 구현하지 않았지만 실제 자바스크립트 어딘가에 전역 변수가 정의되어 있는 상황을 타입스크립트에 알릴 때 엠비언트 타입 선언을 사용한다.

예를 들어 웹뷰를 개발할 때 네이티브 앱과의 통신을 위한 인터페이스를 네이티브 앱이 Win­dow 객체에 추가하는 경우가 많다. 이렇게 전역 객체인 Window에 변수나 함수를 추가하면 타입스크립트에서 직접 구현하지 않았더라도 실제 런타임 환경에서 해당 변수를 시용할 수 있다.

네이티브 앱에서 Window 전역 객체에 deviceId나 appVersion 같은 값을 할당해주는 시나리오를 떠올려보자. Window 객체의 속성은 타입스크립트로 직접 정의한 값이 아니기 때문에 타입스크립트는 해당 속성이 Window 객체의 타입에 존재하지 않는다고 판단한다. 따라서 해당 속성에 접근하려고 하면 Window 객체에 존재하지 않는 속성이라는 에러가 발생한다. 이때 global namespace에 있는 Window 객체에 해당 속성이 정의되어 있다는 것을 나타내기 위해 엠비언트 타입 선언을 사용할수 있다.

```tsx
declare global {
  interface Window {
    deviceld: string | undefined
    appVersion: string
  }
}
```

## (2) 앰비언트 타입 선언시 주의점

### 타입스크립트로 만드는 라이브러리에는 불필요

tsconfig.json의 declaration을 true로 설정하면 타입스크립트 **컴파일러가 .d.ts 파일 을 자동으로 생성**해주기 때문에 수동으로 .d.ts 파일을 작성할 필요가 없다. 따라서 타입스크립트로 라이브러리를 개발할 때는 엠비언트 타입 선언을 사용할 필요가 없다.

### 전역으로 타입을 정의하여 사용할 때 주의해야 할 점

서로 다른 라이브러리에서 동일한 이름의 엠비언트 타입 선언을 한다면 충돌이 발생하여 어떤 타입 선언이 적용될지 알기 어려우며，의도한 대로 동작하지 않을 수 있다. 또한 엠비언트 타입선언은 명시적인 임포트나 익스포트가 없기 때문에 코드의 의존성 관계가 명확하지 않아 나중에 변경할 때 어려움을 겪을 수 있다.

## (3) 앰비언트 타입 선언을 잘못 사용했을 때의 문제점

### 앰비언트 타입 선언을 잘못 사용했을 때의 문제점

.ts 파일 내의 엠비언트 변수 선언은 개발자에게 혼란을 야기할 수 있다.

대표적으로 .ts 파일 내부에 엠비언트 변수를 선언할때 엠비언트 타입의 의존성관계가 보이지 않기 때문에 변경에 의한 영향 범위를 파악하기 어렵다. 왜냐하면 **엠비언트 타입은 명시적인 임포트나 익스포트 없이 코드 전역에서 시용할 수 있기** 때문이다. 특히 소스코드 규모가 크다면 추후 변경이 어려워질 수 있다. 다음과 같이 declare 키워드를 사용한 엠비언트 타입 선언은 .d.ts 파일이 아닌 .ts, .tsx 파일 내에서도 할 수 있다.

엠비언트 변수 선언은 어느 곳에나 영향을 줄 수 있기 때문에 일반 타입 선언과 섞이게 되면 엠비언트 선언이 어떤 파일에 포함되어 있는지 파악하기 어려워진다. 하지만 작은 컴포넌트에 엠비언트 변수 선언이 포함되어 있다면 모든 파일의 타입에 영향을 주기 때문에 어떤 파일에서 엠비언트 타입이 선언되었는지 찾기 어려워진다.
.d.ts 확장자 파일 내에서 앰비언트 타입 선언을 하는 것은 일종의 개발자 간의 약속이다. 타입 선언 위치가 명확해야 가독성이 높아지고 유지보수도 편하게 할 수 있기 때문이다.

## (4) 앰비언트 타입 활용하기

### 타입을 정의하여 임포트 없이 전역으로 공유

.d.ts 파일에서의 엠비언트 타입 선언은 전역 변수와 같은 역할을 한다. 따라서 엠비언트 타입을 선언하면 모든 코드 내에서 임포트하지 않고 사용할 수 있다.

- declare type 활용하기
  보편적으로 많이 사용하는 커스텀 유틸리티 타입을 declare type으로 선언하여 전역에서 사용할 수 있다.
- declare module 활용하기
  CSS-in-JS 라이브러리의 사례 — theme 인터페이스 타입을 확장하여 theme 타입이 자동으로 완성되도록 하는 기능 추가되었다. 정의된 theme에서 스타일 값을 가져와 기존 인터페이스 타입과 통합하여 theme 타입이 자동으로 완성되는 기능을 지원하고 있다.

  ```tsx
  const fontSizes = {
    xl: '30px',
  }

  const colors = {
    gray_100: '#222222',
    gray_200: '#444444',
    // ...
  }

  const depths = {
    origin: 0,
    foreground: 10,
    colors,
    depths,
  }

  declare module 'styled-components' {
    type Theme = typeof theme
    export interface DefaultTheme extends Theme {}
  }
  ```

이외에도 로컬 이미지나 SVG 같이 외부로 노출되어 있지 않은 파일을 모듈로 인식하여 사용할 수 있게끔 만들 수 있다.

- declare namespace 활용하기
  Node.js 환경에서 .env 파일 사용할 때, declare namespace를 활용하여 process.env로 설정값을 손쉽게 불러오고 환경변수의 자동 완성 기능을 쓸 수 있다.
  process.env를 통해 접근하는 변수 또한 타입을 지정할 수 있기 때문에 as 단언을 사용하지 않아도 된다.
- declare global 활용하기
  declare global 키워드는 **전역 변수를 선언할 때 사용**한다. 예를 들어 전역 변수인 Window 객체의 스코프에서 사용되는 모듈이나 변수를 추가할 수 있다.

  ```tsx
  declare global {
    interface Window {
      newProperty: string
    }
  }
  ```

---

배민 사례 — 대표적으로 네이티브 앱과의 통신을 위한 인터페이스를 Window 객체에 추가할 때 엠비언트 타입 선언을 활용할 수 있다. 다음 코드는 iOS 웹뷰에서 자바스크립트로 네이티브 함수를 호출하기 위한 함수를 정의한 것이다. 이를 통해 네이티브 앱과의 통신을 위한 함수를 호출할 때, 자동 완성 기능을 활용하여 실수를 줄일 수 있다.

## (5) declare와 번들러의 시너지

declare global로 전역 변수를 선언하는 과정과 번들러를 통해 데이터를 주입하는 절차를 함께 활용하면 시너지를 낼 수 있다.

전역에 \_color라는 변수가 존재함을 타입스크립트 컴파일러에게 알릴 수 있다.

```tsx
const color = {
  white: '#ffffff',
  black: '#000000',
} as const

type ColorSet = typeof color

declare global {
  const _color: ColorSet
}
```

ColorSet 타입을 가지고 있는 \_color 객체의 실제 데이터가 존재하지 않는다면,
즉, 객체가 존재함을 타입스크립트 컴파일러에 알렸으나, 해당 객체에 해당 타입의 실제 데이터가 존재하지 않을 경우, 타입스크립트 에러를 발생시키지 않지만, 코드가 실행될 경우에는 데이터가 없기 때문에 기대하는 동작과 다를 수 있다.

이러한 문제를 해결하기 위한 방법 중 하나가 번들 시점에 번들러를 통해 데이터를 주입하는 방법으로 이를 해결하는 것이다.

### 롤업 번들러의 inject 모듈로 데이터 주입하는 예시

```tsx
// data.ts
const color = {
  white: '#ffffff',
  black: '#000000',
} as const

// type.ts
import { color } from '.data'
type ColorSet = typeof color

declare global {
  const _color: ColorSet
}

// index.ts
console.log(_color['white']) //  #ffffff

// rollup.config.js
import inject from '@rollup/plugin-inject'
import typescript from '@rollup/plugin-typescript'

export default [
  {
    input: 'index.ts',
    output: [
      {
        dir: 'lib',
        format: 'esm',
      },
    ],
    plugins: [typescript(), inject({ _color: ['./data', 'color'] })],
  },
]
```

data.ts에서 색상을 정의하고 있고, type.ts에서는 해당 데이터로부터 타입을 정의하여 전역적으로 선언하고 있다. index.ts 파일에서는 전역 타입으로 선언된 변수인 \_color['white']를 콘솔로 출력하고 있다. 롤업 번들러 설정에서는 inject 모듈을 사용하여 \_color에 해당하는 데이터를 삽입하고 있다.

### inject 모듈

inject는 임포트문의 경로를 분석하여 데이터를 가져온다.
`import {color} from './data'`
./data 경로에서 color를 가져오는 경우 ['./data', 'color']로 지정하여 어떤 데이터 값을 가져올지 명시할 수 있다.

# 12.2 스크립트와 설정 파일 활용하기

타입스크립트 프로젝트에서 스크립트와 tsconfig 등을 활용하면 개발 생산성을 높일 수 있다.

### (1) 스크립트 활용하기

**✅ 실시간으로 타입 검사하기**

일반적으로 타입스크립트 프로젝트에서는 에디터가 타입 에러를 감지해준다.

그러나 컴퓨터 성능이 떨어지거나 프로젝트 규모가 커지면 에디터가 타입 에러를 알려주는 속도가 느려진다. 때로는 특정 파일을 열어야만 에러가 나타나기도 하며, 커밋 후에 깃훅 도구인 husky에 의해 타입 에러가 발견되기도 한다.

> `yarn tsc --noEmit --incremental -w`
>
> `npx tsc --noEmit --incremental -w`
>
> 스크립트를 사용하여 파일이 변경될 때마다 tsc가 실행되어 실시간으로 타입 에러 확인 가능
>
> - `tsc` 타입스크립트 컴파일러 실행
> - `noEmit` : 자바스크립트로 된 출력 파일 생성하지 않도록 설정
> - `incremental` : 증분 컴파일을 활성화하여 컴파일 시간을 단축할 수 있게 해줌
> - `w` : 파일 변경 사항을 모니터링 (= `--watch`)

**✅  타입 커버리지 확인하기**

현재 프로젝트에서 얼마나 타입스크립트를 적절하게 쓰고 있는지 확인. (any 사용)

> `npx type-coverage --detail`

몇 % 변수가 타입으로 지정되어 있는지 확인할 수 있음

타입스크립트로 마이그레이션 중인 프로젝트나 레거시 코드가 많은 프로젝트를 다룰 때 타입 커버리지를 체크함으로써 더 나은 코드 퀄리티로 리팩터링하기 위한 기반을 마련하는 데 도움 이 되는 정량적인 지표를 얻을 수 있다.

### (2) 설정 파일 활용하기

**✅  타입스크립트 컴파일 속도 높이기**

증분 컴파일 사용하여 컴파일 속도 높이기 (incremental 속성)

### (3) 에디터 활용하기

종종 타입 검사 제대로 안되는 경우 — 타입스크립트 서버 재실행

VSCode에서는 **Restart TS server** 기능 지원 (Command + Shift + P)

## 12.3 타입스크립트 마이그레이션

### (1) 타입스크립트 마이그레이션의 필요성

우아한형제들에서는 JS를 TS로 마이그레이션 한 것보다, TS로 프로젝트를 새로 구축한 사례가 더 많다. 빠르게 변화하는 비즈니스 환경에서는 기존 코드의 구조적 한계가 드러날 수 있다. 따라서 새로운 설계를 바탕으로 타입을 작성하는 게 더 효율적일 수 있다.

### (2) 점진적인 마이그레이션

작은 부분부터 시작하여 점차 범위를 넓혀가며 마이그레이션을 진행하면 진입 장벽도 낮아지고, 안정적으로 전반적인 동작을 유지할 수 있게 된다.

### (3) 마이그레이션 진행하기

타입스크립트 마이그레이션을 진행하기로 했다면 다음과 같은 단계를 거치게 된다.

1. 타입스크립트 개발 환경을 설정하고 빌드 파이프라인에 타입스크립트 컴파일러를 통합한다. tsconfig. json 파일에서 allowJS를 true로 noImplicitAny를 false로 설정해야 한다.

   `allowJS`(기본값: false)는 자바스크립트 파일을 컴파일할 때 사용하는 옵션으로,기존 자바스크립트 함수를 타입스크 립트에서 임포트하거나 반대로 타입스크립트 함수를 자바스크립트에서 임포트할 수 있게 해준다.

   또한 `noImplicitAny`는 암시적 any 타입이 있을 때 오류가 발생하게 하는 옵션이다. 따라서 타입을 점진적으로 추가하는 과정에서는 오류가 발생하지 않도록 noImplicitAny를 false로 설정해야 한다.

2. 작성된 재바스크립트 파일을 타입스크립트 파일로 변환한다. 이 단계에서는 필요한 타입과 인터페이스를 하 나씩 정의하며 함수 사그니처를 추가해나간다.
3. 기존 자바스크립트 파일을 모두 타입스크립트로 변환하는 작업이 완료되었다면 tsconfig.json 파일에서 allowJS를 false로 변경하고 noImplicitAny를 true로 설정하여 타입이 명시되지 않은 부분이 없는지 점검한다.
