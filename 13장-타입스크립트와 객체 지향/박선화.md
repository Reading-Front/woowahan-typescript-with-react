# 13장 타입스크립트와 객체 지향

## 13.1 타입스크립트의 객체 지향

언뜻 보기에 객체 지향은 프론트엔드 개발과는 거리가 먼 개념처럼 느껴질 수 있다.

자바스크립트는 프로토타입 기반의 객체 지향 언어로 분류된다. 자바스크립트의 부족한 부분을 타입스크립트가 private과 같은 접근 제어자나 추상 클래스, 추상 메서드 같은 기능을 지원하면서 해결해준다. 타입스크립트는 객체 지향을 구현할 수 있도록 도와주는 자바스크립트의 슈퍼셋으로 볼 수 있다.

타입스크립트는 점진적 타이핑, 구조적 타이핑 그리고 덕 타이핑이 결합한 언어이다.

- 점진적 타이핑은 프로그램 전체가 아닌 개발자가 명시한 일부분만 정적 타입 검사를 거치게 하고 나머지 부분은 그대로 동적 타입 검사가 이루어지게 한다.
- 덕 타이핑은 객체의 변수와 메서드 집합이 객체의 타입을 결정하게 해준다.
- 구조적 타이핑을 구조적 타입 시스템이라고도 부른다.
  명시적인 선언이나 이름에 의존하여 명확한 상속 관계를 지향하는 노미널 타이핑(Nominal Typin)과는 달리, 구조적 타이핑은 객체의 속성에 해당하는 특정 타입의 속성을 갖는지를 검사하여 타입 호환성을 결정한다.

노미널 타이핑 언어는 인터페이스와 클래스가 일대일로 대응된다. (대표적 노미널 타이핑 언어 : 자바, C#)

구조적 타이핑 언어는 하나의 클래스에 여러 인터페이스가 연결될 수 있으며, 하나의 인터페이스에 여러 클래스가 연결될 수도 있다.

타입스크립트를 활용해 프론트엔드에서 객체 지향을 구현할 수 있다. 우리가 자주 쓰고 있는 컴포넌트도 객체의 한 형태다. 컴포넌트는 스스로 책임을 져야 하는 역할을 수행하면서 다른 컴포넌트 객체와 협력하는 독립적인 객체다. 컴포넌트를 조합하는 것도 객체 지향을 활용하는 것이라고 볼 수 있다.

### 객체 지향 관점에서 타입스크립트가 프론트엔드에 주는 이점

1.  타입스크립트는 prop을 인터페이스로 정의할 수 있다. 객체 지향 패러다임에서는 객체 간의 협력 관계에 초점을 둔다. 컴포넌트 간의 협력 관계를 표현하는 것이 prop이다.

    또한 객체 자체가 아니라 프레임워크에 의해 객체의 의존성이 주입되는 DI(의존성 주입) 패턴을 따르는데, 이러한 패턴을 더욱 명확하게 표현할 수 있게 해주는 것이 타입스크립트다.

    > 우리는 이미 리액트와 같은 도구를 사용하며 DI를 활용하고 있다. DI는 객체 간의 의존 관계를 설정하는 데 사용된다. DI 패턴을 따르면 객체 간의 결합도를 낮출 수 있는데 타입스크립트로 DI 패턴을 더욱 명확하게 표현할 수 있다.

2.  타입스크립트 자체가 객체 지향적으로 다양한 측면을 표현하는 데 큰 장점을 가지고 있다.
    타입스크립트는 점진적 타이핑, 구조적 타이핑 그리고 덕 타이핑이 결합한 언어로 객체 지향의 폭을 넓혀준다.
    컴포넌트 간의 협력 관계를 먼저 고려하고 메시지를 정하는 것은 현실적으로 힘든 일이다. 디자인 요구 사항이 제시되어야 그에 맞춰 마크업을 진행할 수밖에 없다.

        애플리케이션의 변동 사항에 유연하게 대응하기 위해, 변경이 용이하고 유지보수성이 높은 설계를 하기 위해 객체 지향을 구현하는 것인데 사전에 레이아웃의 변화를 예측할 수 없다. 이를 위해 MVP, MVC, MVVM 등의 다양한 패턴이 등장했지만 이것이 만병통치약은 아니다.

프론트엔드 개발에서 객체 지향은 중요한 개념이다. 객체 지향을 따르기 위해서는 객체 간의 협력과 역할에 집중해야 한다.
객체 지향은을 구현하려면 객체 간의 협력관계를 먼저 고려하고, 메시지를 정의하여 해당 메시지를 수신할 알맞은 객체를 결정하는 절차를 따르게 된다.

하지만 컴포넌트를 만들 때 컴포넌트의 역할과 컴포넌트 간의 협력에 초점을 맞추기가 어렵다. JSX와 같은 선언적인 문법을 사용하여 마크업을 처리하는데, 마크업을 선언적으로 작성할 때는 컴포넌트 간의 관계를 먼저 떠올리기 어렵다. 따라서 컴포넌트 간의 협력관계를 먼저 고려하고 메시지를 정하는 것은 현실적으로도 힘든 일이다.

<u>변경이 용이하고 유지보수성이 높은 설계를 하기 위해 객체 지향을 구현하는 것인데 사전에 레이아웃의 변화를 예측할 수 없다. 단지 레이아웃의 변경 사항이 생기면 그저 묵묵히 받아들일 뿐이다.</u>

컴포넌트만 객체일까? 아니다. 상품이 존재하고 이를 담을 수 있는 장바구니가 있다. 이들이 유기적으로 상호작용한다면 객체라고 볼 수 있다. 좀 더 크게 보면 상태 관리 측면에서 유기적인 객체를 생성할 수도 있을 것이다. 특히 MobX는 객체 지향 패러다임을 기반으로 한 대표적인 상태 관리 라이브러리다.

프론트엔드에서 객체 지향을 효과적으로 활용하려면 회사의 전략과 프로젝트의 방향성에 따라 다양한 접근 방식이 있을 것이다. 특히 레이아웃은 예상치 못한 변동 사항이 생길 가능성이 높기 때문에 미확정 영역(gray area)으로 두고 공통으로 사용되는 컴포넌트와 비즈니스 영역에서 객체 지향 원칙을 적용하여 설계하면 좋은 구조를 개발할 수 있을 것이다.

## 13.2 우아한형제들의 활용 방식

우아한형제들의 한 팀에서는 다음과 같은 설계 방식을 사용한다.

- 온전히 레이아웃만 담당하는 **컴포넌트 영역**

  온전히 레이아웃 영역만 담당하고, 비즈니스 로직은 훅 내부 어딘가에 존재할 것이다.

- 컴포넌트 영역 위에서 레이아웃과 비즈니스 로직을 연결해주는 **커스텀 훅 영역**
- 훅 영역 위에서 객체로서 상호 협력하는 **모델 영역**
- 모델 영역 위에서 API를 해석하여 모델로 전달하는 **API 레이어 영역**

예시르 보면 각 객체에 적절한 역할과 책임을 할당하여 올바른 협력을 구성하고 설계해야 하는지를 이해할 수 있을 것이다.

많이 하는 착각 중 하나가 객체 지향 구현 자체를 클래스라고 생각하는 것이다. 전혀 그렇지 않다. 클래스는 객체를 표현하는 방법의 도구일 뿐이다. 컴포넌트를 함수형으로 선언하든 클래스형으로 선언하든 모두 객체를 나타낸다.

리액트 훅이 나오고부터 리액트 공식 문서에서도 함수 컴포넌트를 권장하고 있다. 우리는 적절한 방법을 선택해야 한다. 실제로 틀에서 찍어내듯 일관된 템플릿에 맞춘 컴포넌트를 많이 생성해야 할 때는 클래스 컴포넌트 방식을 따를 때도 있다. 예를 들어 페이지 템플릿을 클래스 컴포넌트로 만들어서 공통으로 정의되어야 할 행동(예: 내비게이션의 뒤로가기 버튼을 눌렀을 때의 동작 등)을 abstract 메서드로 만들어 사용하기도 한다.

## 캡슐화와 추상화

올바른 협력을 설계하기 위해서는 적절한 캡슐화가 이루어져야 한다. 프로젝트 설계의 궁극적인 목표는 객체들이 유기적으로 협력하게끔 만들어서 적절하게 도메인 분리를 하는 것이다. 이를 위해 캡슐화는 중요한 도구가 될 수 있다. 추상화도 별것이 아니다. 객체들을 모델링하는 과정 자체가 추상화다. 이 객체들을 좀 더 사람이 인지할 수 있도록 적합한 설계를 하는 것이 곧 추상화다.

캡슐화란 다른 객체 내부의 데이터를 꺼내와서 직접 다루지 않고, 해당 객체에게 처리할 행위를 따로 요청함으로써 협력하는 것이다. 프론트엔드 관점에서 컴포넌트는 객체이므로 컴포넌트의 내부 데이터인 상태가 바로 캡슐화의 대상이 될 수 있다. 결국 컴포넌트 내의 상태와 prop을 잘 다루는 것도 캡슐화의 개념에 부합하는 것이다.

Prop drilling이 심할수록 컴포넌트 간의 결합도는 높아지며 내부 처리 로직이 외부로 드러나기 마련이다. 즉 Prop drilling은 좋지 못한 관계를 형성하게 하고 캡슐화를 저해한다. 이를 해결하기 위해 옵저버 패턴이 등장했으며 나아가 컨텍스트 API 및 Redux, MobX, Recoil과 같은 다양한 상태 관리 라이브러리가 생겨났다.

적절하게 캡슐화되고 추상화된 컴포넌트를 활용하면 애플리케이션을 더 유기적으로 구성할 수 있다. 최종적으로 지향점은 객체들이 유기적으로 협력하게끔 해서 올바르게 도메인을 분리하는 것이다. 객체 지향 패러다임에 매몰되기보다는 어떻게 하면 더 유기적인 협력 관계를 만들어낼 수 있을지, 명확하게 도메인을 분리할 수 있을지에 집중해보자. 그러면 객체 지향이 추구하고자 하는 방향에 가깝게 프론트엔드 개발을 할 수 있을 것이다.
