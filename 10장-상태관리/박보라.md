# 10장 상태 관리

## 10.1 상태관리

### 1. 상태란

시간이 지나면 변하는 동적인 데이터 (고정 값이 아님)

#### local state

- 컴포넌트 내부에서 관리 되는 데이터
- `useState`, `useReducer` 사용
- ex. 체크박스 여부, 폼의 입력값

#### global state

- 앱 전체에서 공유하는 데이터
- `props drilling` 문제를 피하기 위한 대체제

#### server state

- 외부에서 저장해야 하는 데이터
- `react-query`, `swr` 같은 외부 라이브러리 이용
- ex. 사용자 정보, 글 목록


### 2. 상태를 잘 관리하기 위한 가이드

- 상태가 많을 수록 리렌더링이 많이 됨 -> 성능에 영향이 감
- 따라서, 가능한 Stateless Component를 만드는게 좋음

#### 🏁 Check Point

1️⃣ 시간이 지나도 변하지 않는 값인가? 

- 객체의 참조 동일성 유지해서 변경되지 않은 값임을 리액트가 인식하게 하는 것

- `useState`의 초기값만 지정한다.

- `useRef`를 사용한다.
    - useRef는 매 렌더링 마다 동일한 ref 객체를 제공한다.

2️⃣ 파생된 값인가?

- 부모에게서 전달받는 props이거나 기존 상태에서 계산될 수 있는 값은 상태가 아니다.

- 부모에서 전달받은 props를 상태로 관리하게 될 경우, 동일 출처가 아닌 다른 출처에서 데이터 갱신이 발생하게 됨
  - 따라서, 데이터의 정확성과 일관성을 보장하기 어려움.


```tsx
import { useState } from 'react';

type UserEmailProps = {
    initialEmail: string;
}

const UserEmail: React.VFC<UesrEmailProps> = ({ initialEmail }) => {
    const [email, setEmail] = useState(initialEmail);

    const onChangeEmail = (event: React.ChagneEvent<HTMlInputElement>) => {
        setEmail(event.target.value);
    };

    return (
        <div>
            <input type="text" value={email} onChagne={onChangeEmail}>
        </div>
    )
}

```

> 💡 데이터 상태를 동기화 하기 위해 `useEffect`를 사용하게 되면 어떻게 될까?
>
> `useEffect`를 사용한 동기화 작업은 외부 데이터 (예: `localStorage`)와 동기화 될 때만 사용해야 함.
> 내부에 존재하는 데이터 상태를 동기화 하는 경우, 개발자가 추적하기 어려운 오류가 발생할 수 있음

-> **상태 끌어올리기(Lifting Statg Up)** 기법 

```tsx
import React from 'react';

type UserEmailProps = {
    email: string;
    setEmail: React.Dispatch<React.SetStateAction<string>>;
};

export const UserEmail: React.FC<UserEmailProps> = ({ email, setEmail }) => {
    const onChangeEmail = (event: React.ChangeEvent<HTMLInputElement>) => {
        setEmail(event.target.value);
    };

    return (
        <div>
            <input type="text" value={email} onChange={onChangeEmail} />
        </div>
    );
};

```
- 단일한 출처에서 데이터가 변경되도록 한다.

#### `useState` vs `useReducer`

`useReducer`는 언제 쓸까?
- 다수의 하위 필드를 포함한 복잡한 상태 로직을 다룰 때
- 다음 상태가 이전 상태에 의존적일 때
- useReducer는 '무엇을 변경할지'와 '어떻게 변경할지'를 분리할 수 있다.
    - `dispatch` : 어떤 작업을 할 지 `action`으로 넘김
    - `reducer` : 함수 내에서 상태를 업데이트 하는 방식 정의

```ts
import React, { useReducer } from 'react';

// Action 정의
type Action =
| { payload: ReviewFilter; type: 'filter'; }
| { payload: number; type: 'navigate'; }
| { payload: number; type: 'resize'; };
// Reducer 정의
const reducer: React.Reducer<State, Action> = (state, action) => {
  switch (action.type) {
    case 'filter':
      return {
        filter: action.payload,
        page: 0,
        size: state.size,
      };
    case 'navigate':
      return {
        filter: state.filter,
        page: action.payload,
        size: state.size,
      };
    case 'resize':
      return {
        filter: state.filter,
        page: 0,
        size: action.payload,
      };
    default:
      return state;
    }
};

// useReducer 사용
const [state, dispatch] = useReducer(reducer, getDefaultState());
// dispatch 예시
dispatch({ payload: filter, type: 'filter' });
dispatch({ payload: page, type: 'navigate' });
dispatch({ payload: size, type: 'resize' });

```

### 3. 전역 상태 관리와 상태 관리 라이브러리

상태는 사용하는 곳과 최대한 가깝게 둬야 하고, 사용 범위를 제한해야 한다.

어떤 상태를 컴포넌트 내부에서만 사용하는게 아니라 다른 컴포넌트와 공유하게 될 경우 전역 상태를 사용한다.

전역 상태를 사용하는 방법은
- context API를 사용하는 방법과
- 외부 상태 관리 라이브러리를 사용하는 방법이 있다.

### Context API

다른 컴포넌트들과 데이터 공유를 쉽게 공유하기 위해 만들어짐

전역적으로 공유하는 데이터를 컨텍스트로 제공하고,
그 컨텍스트를 구독한 컴포넌트는 컨텍스트에서 제공하는 데이터를 자유롭게 사용할 수 있다.

ex. 로케일 데이터, ui 테마

## 10.2 상태관리 라이브러리

### ✅ 상태 관리 라이브러리 비교 요약

| 라이브러리 | 특징 / 철학 | 장점 | 단점 |
|-----------|-------------|------|------|
| **MobX** | 관찰 가능한(observable) 상태를 기반으로 자동으로 반응 | - 선언적 코드<br>- 상태 변경 추적이 쉬움<br>- 간결한 문법 | - 추상화 수준이 높아 동작 방식이 불투명할 수 있음<br>- 큰 프로젝트에서 구조화 어려움 |
| **Redux** | 단방향 데이터 흐름 & 순수 함수 기반 (Reducer) | - 명확한 상태 흐름<br>- 미들웨어, DevTools 등 생태계 풍부<br>- 예측 가능성 높음 | - 보일러플레이트 코드 많음<br>- 복잡한 구조 (액션/리듀서 분리) |
| **Recoil** | 페이스북 제작, React의 상태 관리 철학에 잘 부합<br>Atom & Selector 모델 | - 컴포넌트 단위 상태 관리 용이<br>- 비동기 지원(Selector) 자연스러움<br>- 리렌더링 제어 쉬움 | - 아직 생태계 작음<br>- 대규모 프로젝트에서 아토믹 설계 어려움 |
| **Zustand** | 최소한의 API로 상태 공유를 가능하게 하는 간단한 라이브러리 | - 매우 간단한 사용법<br>- 리액트 의존성 적음<br>- 빠른 학습 곡선 | - 명확한 구조가 없어 협업 시 혼란 가능<br>- 상태 분리/설계 주의 필요 |