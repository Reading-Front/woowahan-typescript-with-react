# 2장 타입

## 2.1 타입이란

### 자료형으로서의 타입

특정 메모리에 값을 효율적으로 저장하고 참조하기 위해서는 값의 크기를 알아야 한다.
변수에 저장할 수 있는 값의 종류는 프로그래밍 언어마다 다르다.

ECMAScript 표준을 따르는 자바스크립트는 7가지 데이터 타입을 정의한다.

- undefined
- null
- Boolean
- String
- Symbol
- Numberic(Number와 BigInt)
- Object

데이터 타입은 여러 종류의 데이터를 식별하는 분류 체계로 컴파일러에 값의 형태를 알려준다. 데이터를 식별하는 분류 체계로 컴파일러에 값을 알려주고, 메모리에 저장된 값을 데이터 타입으로 설명할 수 있다.

### 집합으로서의 타입

수학의 집합과 유사하다. 타입은 값이 가질 수 있는 유효한 범위의 집합을 말한다.

어떤 값이 T 타입이라면 컴파일러는 이 값으로 어떤 일을 할 수 있고, 없는지를 사전에 알 수 있다. 타입 시스템은 코드에서 사용되는 유효한 값의 범위를 제한해서 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지해준다.

### 정적 타입과 동적 타입

자바스크립트에도 분명 타입이 존재한다. 다만 개발자가 컴파일 이전에 타입을 직접 정의해줄 필요가 없었을 뿐이다. 타입을 결정하는 시점에 따라 타입을 정적 타입과 동적 타입으로 분류할 수 있다.

**정적 타입 시스템**에서는 모든 변수의 타입이 컴파일타임에 결정된다. 코드 수준에서 개발자가 타입을 명시해줘야 하면 정적 타입 언어에 속한다. 정적 타입 언어는 컴파일타임에 타입 에러를 발견할 수 있어서 프로그램에 안정성을 보장할 수 있다.

**동적 타입 시스템**에서는 변수 타입이 런타임에 결정된다. 개발자가 직접 타입을 정의해줄 필요가 없다. 다만 프로그램을 실행할 때 타입 에러가 발견된다.

### 강타입과 약타입

개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 컴파일러 또는 엔진에 의해서 런타임에 타입이 자동으로 변경되는 것을 **암묵적 타입 변환**이라고 한다.

암묵적 타입 변환 여부에 따라 타입 시스템을 강타입과 약타입으로 분류할 수 있다. **강타입 특징**을 가진 언어에서는 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러가 발생한다. 이에 반해 **약타입 특징**을 갖는 언어에서 서로 다른 타입을 갖는 값끼리 연산할 때는 컴파일러 또는 인터프리터가 내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후 값을 도출한다.

- 강타입 언어 : 파이썬, 루비, 타입스크립트
- 약타입 언어 : C++, 자바, 자바스크립트

python

```python
print('2' - 1) # 에러 발생
```

typescript

```typescript
console.log('2' - 1) // type error
```

javascript

```javascript
console.log('2' - 1) // 1
```

자바스크립트는 약타입 언어이기 때문에 런타임에서 발생할 수 이는 에러를 예측하고 방지하는 코드를 작성하는 것이 프로그램을 안전(타입 안정성)하게 만드는 데 도움이 된다.

#### 타입 시스템

타입을 명시해서 코드를 작성한 후에는 프로그램 내에 기술된 개발자의 의도가 논리적으로 합당한지 검사하는 기준이 필요하다.
타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합을 **타입 시스템**이라고 한다.

타입 시스템은 크게 두 가지로 구분한다.

- 어떤 타입을 사용하는지 컴파일러에 명시적으로 알려줘야 하는 타입 시스템
- 자동으로 타입을 추론하는 타입 시스템

타입스크립트는 두 가지 타입 시스템에 영향을 모두 받았다.

### 컴파일 방식

컴파일의 일반적인 의미는사람이 이해할 수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정을 말한다.

타입스크립트가 탄생한 이유는 사람이 이해하기 쉬운 방식으로 코드를 작성하기 위해서가 아니라 자바스크립트의 컴파일 타임에 런타임 에러를 사전에 잡아내기 위한 것이다. 타입스크립트를 컴파일 하면 타입이 모두 제거된 자바스크립트 소스코드만이 남게 된다.

## 2.2 타입스크립트의 타입 시스템

### 타입 애너테이션 방식

**타입 애너테이션**이란 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법이다. 언어마다 타입을 명시해주는 방법은 다르다.

타입스크립트의 타입 선언 방식은 변수 이름 뒤에 `: type` 구문을 붙여 데이터 타입을 명시해준다.

### 구조적 타이핑

타입을 사용하는 여러 프로그래밍 언어에서 값이나 객체는 하나의 구체적인 타입을 가지고 있다. 타입은 이름으로 구분되며 컴파일타임 이후에도 남아있다. 이것을 **명목적으로 구체화한 타입 시스템**이라고 부르기도 한다.
이름으로 타입을 구분하는 명목적인 타입 언어의 특징과 달리 **타입스크립트는 구조로 타입을 구분**한다. 이것을 **구조적 타이핑**이라고 한다.

### 구조적 서브타이핑

타입스크립트의 타입 시스템을 집합으로 이해할 수 있다. 타입스크립트의 타입은 값의 집합으로 생각할 수 있다. 타입은 단지 집합에 포함되는 값이고 특정 값은 많은 집합에 포함될 수 있다. 이처럼 집합으로 나타낼 수 있는 타입스크립트의 타입 시스템을 지탱하고 있는 개념이 바로 **구조적 서브타이핑**이다.

구조적 서브타이핑이란 객체가 가지고 있는 속성(프로퍼티)을 바탕으로 타입을 구분하는 것이다. 이름이 다른 객체라도 가진 속성이 돌일하다면 타입스크립트는 서로 호환이 가능한 동일 타입으로 여긴다.

```typescript
interface Pet {
  name: string
}
interface Cat {
  name: string
  age: number
}
```

```typescript
let pet: Pet
let cat: Cat = { name: 'Sun', age: 1 }
pet = cat
```

구조적 서브타이핑은 함수의 매개변수에도 적용된다. greet() 함수의 매개변수에는 Pet 타입으로 제한되어 있다. 그러나 타입을 명시하지 않은 cat2 객체를 greet() 함수의 인자로 전달해도 코드는 정상적으로 실행된다.

```typescript
function greet(pet: Pet) {
  console.log('Hello,' + pet.name)
}
const cat2 = { name: 'jay', age: 2 }
greet(cat2) // Hello, jay
```

이와 같은 타이핑 방식이 구조적 타이핑이다. 타입스크립트의 서브타이핑, 즉 타입의 상속 역시 구조적 타이핑을 기반으로 하고 있다.

서로 다른 두 타입간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다. 타입 A가 타입 B의 서브타입이라면 A 타입의 인스턴스는 B 타입이 필요한 곳에 언제든지 위치할 수 있다. 즉, 타입이 계층 구조로부터 자유롭다.

### 명목적 타이핑 vs 구조적 타이핑 vs 덕 타이핑

타입스크립트의 타입 시스템은 구조적 서브타이핑을 사용한다. 이것은 명목적 타이핑과는 대조적인 타이핑 방식이다.
명목적 타이핑은 타입의 동일성을 확인하는 과정에서 구조적 타이핑에 비해 조금 더 안전하다. 명목적 타이핑은 객채의 속성을 다른 객체의 속성과 호황되지 않도록 하여 안전성을 추구한다.

그런데도 타입스크립트가 구조적 타이핑을 채택한 이유는 타입스크립트가 자바스크립트를 모델링한 언어이기 때문이다. 자바스크립트는 본질적으로 덕 타이핑을 기반으로 한다. 덕 타이핑은 어떤 함수의 매개변숫값이 올바르게 주어진다면 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용한다는 개념이다. 따라서 타입스크립트는 명시적 이름으로 타입을 구분하는 대신, 객체나 함수가 가진 구조적 특징을 기반으로 타이핑하는 방식을 택했다.

**자바스크립트의 덕 타이핑**과 **타입스크립트의 구조적 타이핑**은 서로 구분되는 타이핑 방식이지만, 실제 사용하는 코드를 보면 차이가 없어 보인다. 두 가지 타이핑 방식 모두 이름으로 타입을 구분하는 명목적 타이핑과는 달리 객체가 가진 속성을 기반으로 타입을 검사하기 때문이다. 둘의 차이는 **타입을 검사하는 시점**에 있다. 덕 타이핑은 런타임에 타입을 검사하고, 구조적 타이핑은 컴파일 타임에 타입체커가 타입을 검사한다. 덕 타이핑은 주로 동적 타이핑에서, 구조적 타이핑은 정적 타이핑에서 사용된다.

### 타입스크립트의 점진적 타입 확인

타입스크립트는 점진적으로 타입을 확인하는 언어이다. 점진적 타입 검사란 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식이다. 타입 선언을 생략하면 동적으로 검사를 수행하고 암시적 타입 변환이 일어난다.

```typescript
function add(x, y) {
  return x + yl
}

// 위 코드는 이와 같이 암시적 타입 변환이 일어난다.
function add(x; any, y: any): any;
```

타입스크립트에서는 필요에 따라 타입을 생략할 수도 있고 타입을 점진적으로 추가할 수도 있다. 타입스크립트에서 프로그램을 컴파일하는 데 반드시 모든 타입을 알아야 하는 것은 아니지만, 모든 타입을 알고 있을 때 최상의 결과를 보여준다.

### 자바스크립트 슈퍼셋으로서의 타입스크립트

타입스크립트는 기존 자바스크립트 코드에 정적인 타이핑을 추가한 것으로 자바스크립트의 상위 집합이다. 타입스크립트 문법은 모든 자바스크립트 문법을 포함하고 있다.

### 값 vs 타입

값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있다. 타입스크립트 문법인 type으로 선언한 내용은 자바스크립트 런타임에서 제거되기 때문에 값 공간과 타입 공간은 서로 충돌하지 않는다.

값과 타입은 타입스크립트에서 별도의 네임스페이스에 존재한다. 타입스크립트는 개발자가 작성한 코드 문맥을 파악해서 스스로 값 또는 타입으로 해석한다. 각각 사용되는 위치가 다르기 때문에, 코드가 어디에서 사용되었는지에 따라 타입인지 값인지를 추론할 수 있는 것이다. 타입스크립트에서 값과 타입의 구분은 맥락에 따라 달라지기 대문에 값 공간과 타입 공간을 혼동하지 않도록 값과 타입을 구분해서 작성해야 한다.

값과 타입 공간에 동시에 존재하는 경우도 있다. 대표적인 것이 클래스와 enum이다.
ES6에서 등작한 클래스는 객체 인스턴스를 더욱 수비게 생성하기 위한 문법 기능(symantic sugar)으로 실제 동작은 함수와 같다. 동시에 클래스는 타입으로도 사용된다. 즉 타입스크립트 공간에서 클래스는 값과 타입 공간 모두에 포함될 수 있다.

타입스크립트 문법인 enum 역시 런타임에 객체로 변환되는 값이다. enum은 런타임에 실제 객체로 존재하며, 함수로 표현할 수도 있다. enum도 클래스처럼 타입 공간에서 타입을 제한하는 역할을 하지만 자바스크립트 런타임에서 실제 값으로도 사용될 수 있다.

```typescript
enum Direction {
  Up, // 0
  Down, // 1
  Left, // 2
  Right, // 3
}
```

순수 자바스크립트 코드로 컴파일한 결과

```javascript
'use strict'
var Direction
;(function (Direction) {
  Direction[(Direction['Up'] = 0)] = 'Up'
  Direction[(Direction['Down'] = 1)] = 'Down'
  Direction[(Direction['Left'] = 2)] = 'Left'
  Direction[(Direction['Right'] = 3)] = 'Right'
})(Direction || (Direction = {}))
```

타입스크립트에서 어떠한 심볼이 값으로 사용된다는 것은 컴파일러를 사용해서 타입스크립트 파일을 자바스크립트 파일로 변환해도 여전히 자바스크립트 파일에 해당 정보가 남아있음을 의미한다. 반면 타입으로만 사용되는 요소는 컴파일 이후 자바스크립트 파일에서 해당 정보가 사라진다.

### 📌 enum vs 유니온 타입

- 유니온 타입은 어떤 타입을 가졌는지 전부 기억해야 하고, 사용되는 곳을 모두 찾아서 바꿔야 하기 때문에 번거롭다.유니온 타입은 타입이지만 enum은 값이기 때문에 검증이 가능하고, 변경이 있을 경우 편리하기 때문에 넓은 범위에 확장해서 써야 한다면 enum을 쓰고 있다. 또한 코드 가독성도 더 좋은 것 같다.
- enum이 트리쉐이킹이 되지 않아 번들 사이즈에 영향을 줄 수 있지만(전체 번들 사이즈에 영향을 줄만큼 크지 않음) const enum을 사용하면 해결할 수 있다.
  > `const enum`
  > 컴파일 시 값으로 치환되고 디버깅 시에 enum 이름이 아닌 값만 보여지게 된다.
  >
  > - 개발자A : 빌드 과정에서 참조 값만 남기기 때문에 트리쉐이킹이 된다는 장점이 있다. 외부에서 전역저긍로 참조하는 enum의 경우 const enum을 사용한다.
  > - 개발자B : enum과 다르게 직접적인 값으로 치환되기 때문에 전체 네임스페이스에 접근하지 못하고, 순회할 수도 없다는 단점이 있어서 사용하지 않는다.
- enum은 타입을 위한 문법이라기 보다 개발을 위한 문법 같다. 사용하기는 편하지만 자바스크립트로 컴파일될 때 IIFE로 바뀌는 게 크진 않지만 성능에 영향을 줄 수 있다는 것을 본 것 같아서 그 이후로 안 쓰기 시작했다.

> 📌 우형에서의 enum과 const enum 사용 (62p)

### 타입을 확인하는 방법

타입스크립트에서 **typeof**, **instanceof** 그리고 **타입 단언**을 사용해서 타입을 확인할 수 있다.

#### `typeof` 연산자

**typeof**는 연산하기 전에 피연산자의 데이터 타입을 나타내는 문자열을 반환한다. 반환 값은 null을 제외한 6가지 원시 타입과 Function, 호스트 객체 그리고 object 객체가 될 수 있다.

타입스크립트에서 typeof 연산자는 값에서 쓰일 때와 타입에서 쓰일 때의 역할이 다르다.

```typescript
interface Person { ... }
const person: Person = {...}
```

- 값에서 사용된 typeof는 자바스크립트 런타임의 typeof 연산자가 된다.
  ```typescript
  const v1 = typeof person // 값은 'object'
  ```
- 타입에서 사용된 typeof는 값을 읽고 타입스크립트 타입을 반환한다.
  ```typescript
  type T1 = typeof person // 타입 Person
  ```

> 💡 자바스크립트가 처음 만들어졌을 때 (1995년), 값의 타입을 판별하기 위해 내부적으로 null이 메모리상 0x00으로 표현되었고, 이 값이 객체로 인식되도록 구현되었다. 객체는 일반적으로 메모리 주소(레퍼런스)를 갖고 있고, 그 주소가 null일 경우 내부적으로 0과 유사하게 처리되어 "object"로 잘못 분류되었고, 이 버그는 ECMAScript 사양에 포함되어 버려서 하위 호환성을 이유로 지금까지 수정되지 않고 남아 있다.
>
> ```typescript
> console.log(typeof null) // 'object'
> ```

#### `instanceof` 연산자

자바스크립트에서 **instanceof 연산자**를 사용하면 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단할 수 있다. typeof 연산자처럼 instanceof 연산의 필터링으로 타입이 보장된 상태에서 안전하게 값의 타입을 정제하여 사용할 수 있다.

#### 타입 단언

타입스크립트에서는 **타입 단언**에 사용되는 as 키워드를 사용하여 타입을 강제할 수 있다. 개발자가 해당 값의 타입을 더 잘 파악할 수 있을 때 사용되며 강제 형 변환과 유사한 기능을 제공한다.

타입스크립트 코드는 자바스크립트로 변환되고 타입스크립트의 타입 시스템과 문법은 컴파일 단계에서 제거된다. 컴파일 단계에서는 타입 단언이 형 변환을 강제할 수 있지만 런타임에서는 효력을 발휘하지 못한다.

#### 타입 단언

이 외에도 **타입 가드**라는 패턴도 있다. 특정 조건을 검사해서 타입을 정제하고 타입 안정성을 높이는 패턴이다.

## 2.3 원시 타입

자바스크립트에서 값은 타입을 가지지만 변수는 별도의 타입을 가지지 않는다. 따라서 자바스크립트의 변수에는 어떤 타입의 값이라도 자유롭게 할당할 수 있다. 타입스크립트는 이 변수에 타입을 지정할 수 있는 타입 시스템 체계를 구축한다.

### (1) boolean

true와 false 값만 할당 가능하다.
Truthy / Falsy 값은 boolean 원시 값이 아니므로 타입스크립트에서도 boolean 타입에 해당하지 않는다.

### (2) undefined

정의되지 않았다는 의미의 타입으로 오직 undefined 값만 할당할 수 있다.
일반적으로 초기화되지 않은 값을 의미하며 변수 선언만 하고 값을 할당하지 않을 때 undefined가 반환된다.
초기화되어 있지 않거나 존재하지 않음을 나타낸다.

### (3) null

(undefined와 다른 점은) 명시적, 의도적으로 값이 아직 비어있음을 보여줄 때 null을 사용한다.

### (4) number

자바스크립트의 숫자에 해당하는 모든 원시 값을 할당할 수 있다.
숫자가 아님을 나타내는 NaN와, 무한대를 나타내는 Infinity도 포함된다.

### (5) bigInt

ES2020에서 새롭게 도입된 데이터 타입으로 타입스크립트 3.2 버전부터 사용할 수 있다. 이전의 자바스크립트에서는 가장 큰 수인 Number.MAX_SAFE_INTEGER (2^53-1)를 처리할 수 없었는데 bigInt를 사용하면 처리할 수 있다.
number 타입과 bigint 타입은 서로 다른 타입이기 때문에 상호 작요은 불가능하다.

```typescript
const big1: BigInt(9999999);
const big2: 9999999n;
```

### (6) string

문자열을 할당할 수 있는 타입으로, 공백도 포함된다.

### (7) symbol

ES2015에서 도입된 데이터 타입으로 Symbol() 함수를 사용하면 어떤 값과도 중복되지 않는 유일한 값을 생성할 수 있다.
동일한 문자열을 넘겨줬을 때도 서로 다른 값을 가진다.

```typescript
const S1 = Symbol('symbol')
const S2 = Symbol('symbol')

console.log(S1 === S2) // false
// This comparison appears to be unintentional because the types 'typeof S1' and 'typeof S2' have no overlap. 이 비교는 'typeof S1'과 'typeof S2' 유형이 겹치지 않기 때문에 의도하지 않은 것으로 보입니다.
```

타입스크립트에는 symbol 타입과 const 선언에서만 사용할 수 있는 unique symbol 타입이라는 symbol의 하위 타입도 있다.

```typescript
const SYMBOL1: unique symbol = Symbol()
let SYMBOL2: unique symbol = Symbol()
// A variable whose type is a 'unique symbol' type must be 'const'.
```

## 2.4 객체 타입

7가지 원시 타입에 속하지 않은 값은 모두 객체 타입으로 분류할 수 있다.

### object

object 타입은 가급적 사용하지 않는 것이 좋다. any 타입과 유사하게 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색되기 때문이다.

객체, 배열, 정규 표현식, 함수, 클래스 등 모두 object 타입과 호환된다. 원시 타입과는 호환되지 않는다.

### {}

중괄호는 자바스크립트에서 객체 리터럴 방식으로 객체를 생성할 때 사용하며, 타입스크립트에서 객체를 타이핑할 때도 중괄호를 쓸 수 있다. 중괄호 안에 객체의 속성 타입을 지정해주는 식으로 사용한다.

타입스크립트에서 `{}`는 자바스크립트와 마찬가지로 빈 객체임을 의미한다. {} 타입으로 지정된 객체에는 어떤 값도 속성으로 할당할 수 없다.
사실 빈 객체 타입을 지정하기 위해서는 {}보다 유틸리티 타입으로 Record<string, never>처럼 사용하는게 바람직하다.
{} 타입으로 지정된 객체는 완전히 비어있는 순수한 객체를 의미하는 것이 아니다. 자바스크립트 프로토타입 체이닝으로 Object 객체 래퍼에서 제공하는 속성에는 정상적으로 접근할 수 있다. 이런 이유로 잘 사용하지 않는다.

### array

자바스크립트의 배열 자료구조는 원소를 자유롭게 추가하고 제거할 수 있으며 타입 제한 없이 다양한 값을 다룬다. 즉 하나의 배열 안에 숫자, 문자열과 같은 서로 다른 값이 혼재될 수 있다. 따라서 이는 타입스크립트가 추구하는 정적 타이핑과는 맞지 않다.

타입스크립트에서는 배열을 array라는 별도 타입으로 다룬다. 타입스크립트 배열 타입은 하나의 타입 값만 가질 수 있다는 점에서 자바스크립트 배열보다 조금 더 엄격하다. 하지만 원소 개수는 타입에 영향을 주지 않는다.

타입스크립트에서 배열 타입을 선언하는 방식은 Array 키워드로 선언하거나 대괄호를 사용해서 선언하는 방법이 있다. 두 방식은 결과적으로 같다.

> ### 튜플 타입
>
> **튜플 타입**도 대괄호로 선언한다. 타입스크립트 튜플 타입은 배열과 유사하지만 튜플의 대괄호 내부에는 선언 시점에 지정해준 타입 값만 할당할 수 있다. 원소 개수도 타입 선언 지점에 미리 정해진다.
>
> ```typescript
> const BloodTypes: ['A', 'B', 'O', 'AB'] = ['A', 'B', 'O', 'AB']
> ```

### type과 interface 키워드를 사용하는 객체 타이핑

타입스크립트에서는 객체를 타이핑하기 위해 흔히 type과 interface 키워드를 사용한다.

### function

자바스크립트에서는 함수도 일종의 객체로 간주하지만 typeof 연산자로 함수 타입을 출력해보면 자바스크립트는 함수를 function 이라는 별도 타입으로 분류하는 것을 확인할 수 있다. 마찬가지로 타입스크립트에서도 함수를 별도 함수 타입으로 지정할 수 있다.

함수의 매개변수와 반환 값에 대한 타입을 지정할 수 있다.

```typescript
function add(a: number, b: number): number {
  return a + b
}
```

#### 호출 시그니처

함수 자체의 타입의 경우는 호출 시그니처를 정의하는 방식을 사용하면 된다.
타입스크립트에서 함수 타입을 정의할 때 사용하는 문법으로, 함수의 매개변수와 반환 값의 타입을 명시하는 역할을 한다.

```typescript
type add = (a: number, b: number) => number
```
