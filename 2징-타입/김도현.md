## 구조적 타이핑

타입을 이름이 아니라 구조(속성과 타입)로 판단하는 TypeScript의 타입 시스템 방식입니다.

```tsx
type User = { name: string };

const person = { name: "Alice", age: 30 };

const user: User = person; // ✅ 구조가 일치하므로 가능 O
```

- `person`에는 `age`가 있지만, `User` 타입이 요구하는 `name: string` 속성이 있기 때문에 할당 가능합니다.

- 타입의 **모양이 일치**하면, 이름이 달라도 사용할 수 있습니다.

## 구조적 서브 타이핑

"구조적 타이핑" 개념을 바탕으로 **한 타입이 다른 타입의 부분집합일 경우, 서브타입으로 간주**하는 방식입니다.

- `타입 A가 타입 B보다 속성 구조적으로 더 많거나 같으면, A는 B의 서브타입이다.`
- **A extends B**가 성립됨 → **A is assignable to B**

```tsx
type Person = { name: string };
type Developer = { name: string; skills: string[] };

const dev: Developer = { name: "Tom", skills: ["TS", "React"] };
const person: Person = dev; // ✅ Developer는 Person보다 더 많은 속성을 가짐
```

- `Developer`는 `Person`의 속성(name)을 포함하고, 추가 속성(skills)을 가졌습니다.
- 따라서 `Developer`는 `Person`의 구조적 서브타입이 되어 할당 가능합니다.

---

## 구조적 타이핑의 결과

```tsx
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0;

  for (const axis of Object.keys(c)) {
    // Object.keys(c)는 string[] 타입입니다.
    const length = c[axis]; // `axis`는 `string` 타입으로 `Cube`를 인덱싱할 수 없기 때문에 에러가 발생합니다.
    total += length;
  }
}

const cube = {
  width: 10,
  height: 20,
  depth: 30,
};

// 함수 호출 및 결과 출력
const totalLength = addLines(cube);
console.log(`각 축의 길이를 더한 값: ${totalLength}`);
```

- `Cube` 타입은 **명시적으로** `width`, `height`, `depth`라는 키를 가지는 객체입니다. 즉, `Cube` 타입의 키는 **정해져 있습니다**.
- 그런데 `const axis of Object.keys(c)`는 키 값인 axis는 `string` 타입으로 반환되기 때문에 **정확한 타입을 추론하지 못합니다**.
- `Cube` 타입은 `width`, `height`, `depth`라는 구체적인 키만 허용하는 객체인데, `axis`는 `string` 타입이기 때문에, TypeScript는 `c[axis]`가 유효한 키인지 확인할 수 없습니다.
- 따라서 **타입 오류가 발생합니다.**

### 해결 방법 1

`axis`가 `Cube`의 키 중 하나임을 확신하고, 이를 TypeScript에 명시적으로 알려줘야 합니다.

```tsx
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0;

  for (const axis of Object.keys(c)) {
    // `axis`를 `keyof Cube`로 타입 단언
    const length = c[axis as keyof Cube];
    total += length;
  }

  return total;
}
const cube = {
  width: 10,
  height: 20,
  depth: 30,
};

// 함수 호출 및 결과 출력
const totalLength = addLines(cube);
console.log(`각 축의 길이를 더한 값: ${totalLength}`);
```

### 해결 방법 2: `Object.entries` 사용

`Object.entries(c)`를 사용하면 키와 값을 쌍으로 가져올 수 있으므로, `axis`의 타입을 정확하게 추론할 수 있습니다.

```tsx
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0;

  for (const [, length] of Object.entries(c)) {
    total += length;
  }

  return total;
}

const cube = {
  width: 10,
  height: 20,
  depth: 30,
};

// 함수 호출 및 결과 출력
const totalLength = addLines(cube);
console.log(`각 축의 길이를 더한 값: ${totalLength}`);
```
