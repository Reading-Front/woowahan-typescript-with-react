# 2장 타입

## 2.1 타입이란

타입이란 값이 가질 수 있는 데이터의 형태를 의미한다.

### 2.1.1 자료형으로서의 타입

타입은 데이터의 종류와 구조를 정의하는 자료형이다.

자바스크립트는 7가지 **데이터 타입(자료형)** 을 정의한다.

- 원시타입(Primitive Type)
  - `number`
  - `string`
  - `boolean`
  - `null`
  - `undefined`
  - `symbol`
  - `bigint`

데이터 타입은 값의 범위와 표현 방식을 정의한다.

모든 데이터를 해석할 때, 데이터 타입 체계가 사용된다.

메모리 관점에서의 "*데이터 타입*"은 프로그래밍 언어에서 일반적으로 부르고 있는 "*타입*"과 개념이 같다.

### 2.1.2 집합으로서의 타입

타입은 집합으로 표현된다.

타입은 값이 가질 수 있는 유효한 범위의 집합을 말한다.

특정 타입에 속한 값은 해당 타입의 집합에 포함된 원소이다.

예를 들어,

- `string` 타입은 모든 문자열의 집합이다.
- 유니온 타입은 여러 타입의 집합이다.

```typescript
// string 타입은 모든 문자열 값의 집합
const stringSet: string = "안녕하세요";

// 유니온 타입은 여러 집합의 합집합
type StringOrNumber = string | number;
const union: StringOrNumber = "안녕하세요";
const union2: StringOrNumber = 123;
```

### 2.1.3 정적 타입과 동적 타입

- 정적 타입: 컴파일 시점에 타입 검사 (타입스크립트)
- 동적 타입: 런타임 시점에 타입 결정 (자바스크립트)

```typescript
// 정적 타입 시스템의 예
function add(a: number, b: number): number {
  return a + b;
}

add(1, 2); // 정상
add("1", "2"); // 🚨 컴파일 오류
```

```typescript
// 동적 타입 시스템의 예
function add(a, b) {
  return a + b;
}

add(1, 2); // 정상
add("1", "2"); // 정상
```

### 2.1.4 강타입과 약타입

모든 프로그래밍 언어에는 값의 타입이 존재한다.

타입이 결정되는 시점이 다를 뿐이다.

> 📝 암묵적 타입 변환
>
> 개발자가 의도적으로 명시하거나 바꾸지 않았는데, 컴파일러 또는 엔진에 의해서 런타임에 자동으로 타입이 변경되는 것을 암묵적 타입 변환이라 한다.

암묵적 타입 변환 여부에 따라 타입 시스템을 강타입 or 약타입으로 나눌 수 있다.

- 강타입: 타입 검사를 **엄격** 하게 적용 (타입스크립트)
- 약타입: 타입 검사를 **느슨** 하게 적용 (자바스크립트)

### 2.1.5 컴파일 방식

> 📝 컴파일 방식이란?
>
> 사람이 이해하는 코드를 컴퓨터가 이해하는 코드로 변환하는 과정
>
> 즉, 고수준 언어를 저수준 언어(바이너리 코드 = 0과 1로 이루어진 이진코드)로 변환하는 과정

타입스크립트는 컴파일 방식으로 작동한다.

컴파일 방식은 소스 코드를 먼저 컴파일하고, 컴파일된 코드를 실행한다.

📝 **정적 타입 언어**는 코드를 작성하고 컴파일할 때 타입 검사를 실행한다.
타입스크립트는 개발자가 명시적으로 타입을 선언하고, 컴파일 타임에 타입 오류를 미리 확인할 수 있다.
이는 런타임 에러를 사전에 방지하고, 더 견고한 코드를 작성하도록 도와준다.

반면, **동적 타입 언어(자바스크립트 등)** 는 컴파일 단계가 없거나 약해, 실제 실행 시에만 타입 오류를 확인할 수 있다.

```typescript
// 컴파일 타임에 타입 체크
let userName: string = "홍길동";
userName = 1234; // 컴파일 단계에서 타입 에러 발생
```

## 2.2 타입스크립트의 타입 시스템

### 2.2.1 타입 애터네이션 방식

타입 어노테이션(annotaion = '선언') 이란,

변수/상수/함수에 타입을 명시적으로 **선언** 해서 컴파일러에게  어떤 값이 지정될 지를 미리 알려주는 역할을 한다.

```typescript
const name: string = '보라돌이';
```

### 2.2.2 구조적 타이핑

타입스크립트는 구조적 타이핑을 사용하여 타입 호환성을 결정한다.

이는, 타입의 이름이 아닌 구조(속성과 메서드)를 기준으로 타입을 비교한다.

```typescript
interface Developer {
  name: string;
  skill: string;
}

interface Person {
  name: string;
  age: number;
}

let developer: Developer = { name: "Kim", skill: "TypeScript" };
let person: Person = { name: "Lee", age: 28 };

// 구조적으로 호환되지 않음
developer = person; // 오류: 'skill' 속성이 없음
```

### 2.2.3 구조적 서브 타이핑

구조적 서브타이핑은 객체가 가진 속성을 기준으로 타입 호환성을 판단하는 원칙이다.

이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환되는 타입으로 간주한다.

```typescript
interface Developer {
  name: string;
}

interface FrontendDev {
  name: string;
  skill: string;
}

let developer: Developer;
let frontendDev: FrontendDev = { name: "Park", skill: "React" };

// FrontendDev는 Developer의 모든 속성을 포함하므로 할당 가능
developer = frontendDev; // 정상
```

`Developer` 타입과 `FrontendDev` 타입은 서로 다른 타입으로 선언되었지만, `name` 속성이 동일하므로 developer에 frontendDev를 할당할 수 있다.

함수의 매개변수에도 적용된다.

```typescript
interface Developer {
  name: string;
}

interface FrontendDev {
  name: string;
  skill: string;
}

function printName(person: Developer) {
  console.log(person.name);
}

const developer = { name: "Park", skill: "React" };

printName(developer); // Park
```

developer 객체는 `Developer` 타입의 속성을 모두 가지고 있으므로, `Developer` 타입으로 할당할 수 있다.

이같은 방식이 타입스크립트의 구조적 타이핑이다.

타입스크립트의 서브 타이핑, 즉 타입의 상속 역시 구조적 타이핑을 기반으로 한다.

```typescript
class Developer {
  name: string;

  constructor(name: string) {
    this.name = name;
  }
}

class FrontendDev {
  name: string;
  skill: string;

  constructor(name: string, skill: string) {
    this.name = name;
    this.skill = skill;
  }
}

function printName(person: Developer) {
  console.log(person.name);
}

const developer = new Developer("Park");
const frontendDev = new FrontendDev("Park", "React");

printName(frontendDev); // Park
```

`FrontendDev` 클래스가 `Developer` 클래스를 상속받지 않았음에도 불구하고, `printName` 함수에 `FrontendDev` 객체를 전달할 수 있다.

이는 `FrontendDev` 객체가 `Developer` 타입의 속성을 모두 가지고 있기 때문이다.

이같은 방식이 타입스크립트의 구조적 서브타이핑이다.

### 2.2.4 자바스크립트를 닮은 타입스크립트

타입스크립트는 자바스크립트와 100% 호환되는 확장 언어로, 기존 자바스크립트의 특성을 유지하면서도 타입 시스템을 추가했다.

✔️ 호환성과 기본 원칙

- 타입스크립트는 자바스크립트의 상위 집합(superset)으로 설계했다.
- 유효한 자바스크립트 코드는 대부분 타입스크립트로도 유효하다.
- 기존 자바스크립트 프로젝트를 점진적으로 타입스크립트로 마이그레이션 가능하다.

✔️ 타입 시스템의 특징

- 선택적 타입 시스템(Optional Type System)
- 타입 어노테이션을 추가하지 않아도 기본적으로 동작한다.
- 타입스크립트 컴파일러(TSC)는 자바스크립트 코드를 생성한다.

✔️ 기존 자바스크립트 코드와의 관계

- 모든 자바스크립트 라이브러리와 함께 사용할 수 있다.
- 필요에 따라 점진적으로 타입을 추가할 수 있다.
- `.js` 파일을 `.ts` 파일로 변경하는 것만으로도 기본적인 타입 체크가 가능하다.

✔️ 런타임 동작

- 타입스크립트의 타입 체크는 컴파일 타임에만 이루어진다.
- 런타임에는 모든 타입 정보가 제거되어 일반 자바스크립트처럼 동작한다.
- 타입 체크에 실패해도 자바스크립트 코드는 생성될 수 있다(설정에 따라 다름)

✔️ 타입 추론과 확장

- 자바스크립트의 동적 타이핑 특성을 반영하여 강력한 타입 추론 기능을 제공한다.
- 자바스크립트의 객체 지향 프로그래밍 패턴을 타입 시스템으로 확장한다.
- 자바스크립트의 프로토타입 기반 상속도 클래스 기반으로 표현할 수 있다.

이처럼 타입스크립트는 자바스크립트의 유연성과 생산성을 유지하면서도, 타입 시스템을 통해 코드의 안정성과 유지보수성을 크게 향상시킨다.

### 2.2.5 구조적 타이핑 결과

### 2.2.6 타입스크립트의 점진적 타입 확인

### 2.2.7 자바스크립트 슈퍼셋으로서의 타입스크립트

### 2.2.8 값 vs 타입

### 2.2.9 타입을 확인하는 방법
