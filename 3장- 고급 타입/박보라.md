# 3장 고급 타입

## 3.1 타입스크립트만의 독자적 타입 시스템

### 3.1.1 any 타입

- 임시 변수, 외부 라이브러리 사용, 예측 불가한 값에 사용.
- 컴파일러가 타입 검사를 하지 않음.

```ts
let value: any = 5;
value = "hello";  // 가능
value.toUpperCase(); // 가능하지만 런타임 에러 가능성 있음
```

### 3.1.2 unknown 타입

- any보다 안전한 타입. 실제 사용 전에는 타입 확인이 필요.

```ts
let input: unknown = "hi";

if (typeof input === "string") {
  console.log(input.toUpperCase()); // OK
}
```

### 3.1.3 void 타입

- 함수에서 반환값이 없을 때 사용.

```ts
function log(message: string): void {
  console.log(message);
}
```

### 3.1.4 never 타입

- 절대 반환되지 않는 함수에 사용. 주로 에러 던지기나 무한 루프에 사용.

```ts
function fail(): never {
  throw new Error("예외 발생");
}

function infinite(): never {
  while (true) {}
}
```

### 3.1.5 Array 타입

- 기본 배열 타입 선언: string[], Array<number> 두 가지 방식 가능.

```ts
let names: string[] = ["Alice", "Bob"];
let nums: Array<number> = [1, 2, 3];
```

### 3.1.6 enum 타입

- 의미 있는 이름을 가진 상수 집합을 정의할 때 사용.

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right
}

let dir: Direction = Direction.Up;
```

## 3.2 타입 조합

### 3.2.1 교차 타입 (Intersection Type)

- 여러 타입을 합쳐서 하나의 타입으로 정의.

```ts
type Person = { name: string };
type Worker = { company: string };
type Employee = Person & Worker;

const e: Employee = { name: "Anna", company: "OpenAI" };

```

### 3.2.2 유니온 타입 (Union Type)

- 둘 중 하나의 타입을 가질 수 있음.

```ts
type Status = "loading" | "success" | "error";

function show(status: Status) {
  if (status === "loading") console.log("로딩 중");
}
```

### 3.2.3 인덱스 시그니처 (Index Signatures)

- 동적 키를 갖는 객체 타입 정의.

```ts
interface Dictionary {
  [key: string]: string;
}

const dict: Dictionary = {
  hello: "안녕",
  world: "세계"
};
```

### 3.2.4 인덱스드 엑세스 타입 (Indexed Access Types)

- 타입에서 특정 속성의 타입을 추출.

```ts
type User = { name: string; age: number };
type UserName = User["name"]; // string
```

### 3.2.5 맵드 타입 (Mapped Types)

- 기존 타입을 반복적으로 변환하여 새로운 타입 생성.

```ts
type Optional<T> = {
  [K in keyof T]?: T[K];
};

type User = { name: string; age: number };
type PartialUser = Optional<User>; // 모든 속성이 optional
```

### 3.2.6 템플릿 리터럴 타입 (Template Literal Types)

- 문자열 조합으로 타입 생성 가능.

```ts
type Lang = "ko" | "en";
type MessageKey = `msg_${Lang}`; // "msg_ko" | "msg_en"
```

### 3.2.7 제네릭 (기본 개념 소개)

- 타입을 함수처럼 인자로 받아 재사용 가능한 타입 생성.

```ts
function wrap<T>(value: T): { value: T } {
  return { value };
}

```

## 3.3 제네릭 사용법

### 3.3.1 함수의 제네릭

```ts
function identity<T>(arg: T): T {
  return arg;
}
```

### 3.3.2 호출 시그니처의 제네릭

```ts
type Mapper<T> = (x: T) => T;

const double: Mapper<number> = (x) => x * 2;
```

### 3.3.3 제네릭 클래스

```ts
class Container<T> {
  private _value: T;
  constructor(value: T) {
    this._value = value;
  }
  get value(): T {
    return this._value;
  }
}
```

### 3.3.4 제한된 제네릭 (extends)

```ts
function getLength<T extends { length: number }>(value: T) {
  return value.length;
}
```

### 3.3.5 확장된 제네릭

- 제네릭 타입끼리 조합하거나 중첩해서 더 복잡한 타입 구현.

```ts
function merge<T extends object, U extends object>(a: T, b: U): T & U {
  return { ...a, ...b };
}
```

### 3.3.6 제네릭 예시 (오용 사례 포함)

- 굳이 제네릭을 쓰지 않아도 되는 경우:

```ts
function noNeed<T>(value: string): string {
  return value;
}
```

- 제네릭 불필요. 그냥 string으로 선언하면 됨.

```ts
function parseJSON(json: string): any {
  return JSON.parse(json);
}

```

- 가독성을 해치는 제네릭

```ts
function complex<T extends keyof any, U extends Record<T, any>>(k: T, o: U): any {
  return o[k];
}
```

- 너무 과도한 제네릭은 읽기 어렵고 유지보수 힘듦
