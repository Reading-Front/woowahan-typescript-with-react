# 7장

## 7.1 API 요청

### 7.1.1 fetch로 API 요청하기
### 7.1.2 서비스 레이어로 분기하기
### 7.1.3 Axios 활용하기
### 7.1.4 Axios 인터셉터 활용하기
### 7.1.5 API 응답 타입 지정하기
### 7.1.6 뷰 모델(View Model) 사용하기
### 7.1.7 Superstruct 사용해서 런타이 응답 타입 검증하기
### 7.1.8 실제 API 응답 시의 Superstruct 활용 사례

## 7.2 API 상태 관리하기
### 7.2.1 상태 관리 라이브러리에서 호출하기
### 7.2.2 훅으로 호출하기

## 7.3 API 에러 핸들링

### 7.3.1 타입 가드 활용하기
### 7.3.2 에러 서브클래싱하기
### 7.3.3 인터셉터를 활용한 에러 처리
### 7.3.4 에러 바운더리를 활용한 에러 처리
### 7.3.5 상태 관리 라이브러리에서의 에러 처리
### 7.3.6 react-query를 활용한 에러 처리
### 7.3.7 그 밖의 에러 처리

## 7.4 API 모킹

백엔드 서버가 준비되기 전에 프론트 단에서 동적 ui 를 보여주기 위해 임시로 사용하는 방법
- 서버의 영향을 받지 않고 프론트 개발이 가능함

### 7.4.1 JSON 파일 불러오기
- 간단한 조회만 필요할 경우

### 7.4.2 NextApiHandler 활용하기

```ts
// api/mock/brand
import { NextApiHandler } from 'next';

const users = [
    {
        id: 1,
        name: 'John',
    },
    {
        id: 2,
        name: 'Marry',
    }
]

const handler: NextApiHandler = (req, res) => {
    res.json();
}
```

### 7.4.3 API 요청 핸들러에 분기 추가하기

- 평소 개발시에는 mock API 사용하고, 필요한 경우에만 실제 요청을 보낼 경우

```ts
const mockFetchUsers = (): Promise<FetchUserResponse> => new Promise((resolve) => {
    setTimeout(() => {
        resolve({
            status: 'SUCCESS',
            message: null,
            data: users
        })
    }, 5000)
})

const fetchUsers = () => {
    if(useMock){
        return mockFetchUsers();
    }
    return requester.get("/users");
}
```

### 7.4.4 axios-mock-adapter로 모킹하기


### 7.4.5 목업 사용 여부 제어하기
